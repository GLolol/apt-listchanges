#!/usr/bin/perl

#
#      apt-listchanges - Show changelog entries between the installed versions
#        of a set of packages and the versions contained in corresponding
#        .deb files
#
#      Copyright (C) 2000  Matt Zimmerman <mdz@debian.org>
#
#      This program is free software; you can redistribute it and/or modify
#      it under the terms of the GNU General Public License as published by
#      the Free Software Foundation; either version 2 of the License, or
#      (at your option) any later version.
#
#      This program is distributed in the hope that it will be useful,
#      but WITHOUT ANY WARRANTY; without even the implied warranty of
#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#      GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public
#      License along with this program; if not, write to the Free
#      Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
#      MA 02111-1307 USA
#

# This is @PACKAGE@, version @VERSION@

use strict;
use Getopt::Long;
use Sys::Hostname;
use IO::Handle;

# Read config file
my %config;
&read_config('/etc/apt/listchanges.conf', \%config);

# Config file options can be overridden by command line options
my $apt_mode = 0;
my $verbose = 0;
my $frontend_opt = $config{'frontend'} || 'pager';
my $email_address = $config{'email-address'} || 'root';
my $show_all = 0;
my $confirm;

GetOptions("apt" => \$apt_mode,
	   "verbose|v" => \$verbose,
	   "frontend|f=s" => \$frontend_opt,
	   "email-address=s" => \$email_address,
	   "confirm|c!" => \$confirm,
	   "all|a" => \$show_all) || die;

if ($apt_mode) {
  $confirm ||= ( $config{'apt-mode-confirm'} eq 'yes' );
}

# Hash of package info from the status file
my %status;

# List of filenames to process
my @debs;

# Hash of source packages that we've processed (to avoid duplicates)
my %source_packages_processed;

# Numeric urgency values for sorting.  Unknown urgencies get sorted to
# the top (equivalent to 'high'), since there is no fixed list of
# urgency values and it would be much more probable that an unknown
# urgency value would be higher than lower ("this package needs to get
# out at extra-low priority!")
my %urgency = ( 'low' => 2,
		'medium' => 1,
		'high' => 0 );

# Changelog text
my @changes;

# Error text
my $errors;

##
## Initialization
##

my @debs = read_deb_filenames($apt_mode, \%status);

unless (@debs) {
  exit 0 if ($apt_mode);
  die "apt-listchanges: Must specify either --apt or filenames to process!\n";
}

# Only reads the status file if we haven't already gotten the info
# from apt via read_deb_filenames
read_status(\%status) unless $show_all;

# User interaction
my $frontend = frontend_init($frontend_opt);

##
## Main loop
##
foreach my $deb (@debs) {
  &{ $frontend->{update_progress} }($frontend);

  # Find out what package we are installing
  my ($pkg, $version, $oldversion, $sourcepackage) =
      get_package_info($deb, \%status);

  # Bail if things don't look right
  unless ($pkg) {
    $errors .= "apt-listchanges: Unable to determine package name for $deb\n";
    next;
  }
  unless ($version) {
    $errors .= "apt-listchanges: Unable to determine version for $deb\n";
    next;
  }
  unless ($sourcepackage) {
    $errors .= "apt-listchanges: Unable to determine source package name for $deb\n";
    next;
  }

  # Skip if the package is not installed
  if (!$show_all && !$oldversion) {
    $changes[$urgency{'low'}] .= "$pkg: will be newly installed\n\n"
	if $verbose;
    next;
  }

  # Skip if we are looking at the same version (faster than asking dpkg)
  if ($version eq $oldversion) {

    $changes[$urgency{'low'}] .=
	"$pkg: Version $version is already installed\n\n"
	if $verbose;

    next;
  }

  # Skip if we are looking at an older version
  if (!$show_all && dpkg_compare_versions($version, 'le', $oldversion)) {
    $changes[$urgency{'low'}] .=
	"$pkg: Version $version is older than installed version ($oldversion)\n\n"
	if $verbose;
    next;
  }

  # Skip if we already processed another binary package from this
  # source package
  next if $source_packages_processed{$sourcepackage};

  # Determine the changelog filenames
  my @changelog_filenames = ('changelog.Debian');

  # Check both compressed and uncompressed
  @changelog_filenames = map { ($_, "$_.gz") } @changelog_filenames;

  # Check both /usr/doc and /usr/share/doc
  @changelog_filenames = map { ("./usr/doc/$pkg/$_",
				  "./usr/share/doc/$pkg/$_") }
				  @changelog_filenames;

  my @changelog_filenames_nodebian = @changelog_filenames;

  # Strip .Debian to check native packages
  map { s/\.Debian//g } @changelog_filenames_nodebian;

  # First try changelog.Debian and friends.  If we don't find one, it
  # will be a native package that doesn't provide a changelog.Debian,
  # so we try plain changelog

  foreach my $changelog_filenames (\@changelog_filenames,
				   \@changelog_filenames_nodebian) {

    # Extract relevant changelog info
    open(DPKGDEB, "dpkg-deb --fsys-tarfile $deb | tar xOf - @$changelog_filenames 2>/dev/null | zcat -f|") || die $!;
    
    my $lines_read = 0;
    my $urgency = $urgency{'low'};
    my $changes;
    while (<DPKGDEB>) {
      ++$lines_read;
      
      if ( /^(tar|dpkg-deb):/ ) {
	# Errors from tar or dpkg-deb
	$errors .= $_;
	next;
      }
      
      if ( /^\S+ \((.*)\) .*; urgency=(.*)$/ ) {
	last if !$show_all && dpkg_compare_versions($1, 'le', $oldversion);

	# Use the urgency of the most urgent changelog entry for the
	# urgency of this package
	$urgency = $urgency{$2} < $urgency ? $urgency{$2} : $urgency;
      }
      
      $changes .= $_;
    }

    $changes[$urgency] .= $changes if $changes;
    
    # Read any remaining data from a large changelog, to avoid a 'broken
    # pipe' error message on close
    while (<DPKGDEB>) {}
    close(DPKGDEB);

    # Quit if we got something (don't try the next set of changelog
    # filenames)
    if ( $lines_read > 0 ) {
      ++$source_packages_processed{$sourcepackage};
      last;
    }
 }

}

my $output = join('', @changes);
if ($errors) {
  $output .= "\napt-listchanges: Error output follows\n";
  $output .= $errors;
}

&{ $frontend->{display_output} }($frontend, $output);

if ($confirm && $output) {
  exit 1 unless &{ $frontend->{confirm} }($frontend);
}

exit 0;

## End top level ##

# Initialize the frontend...this is a little bit hairy.  We return a
# reference (really, a fake object) containing subroutine refs These
# expect to be called with a reference to the fake object as their
# first argument, just as a real object's methods would.  The code for
# all of the frontends is in here.
#
# The subroutine refs are:
#
# init - Initialize the frontend
# update_progress - update a progress meter
# display_output - Show the user some text
# confirm - Ask the user whether to continue (return false if not)
#

sub frontend_init {
  my ($frontend_opt) = @_;
  
  my %frontends;

  $frontends{'newt'} = {
    'init' => sub {
      my ($this) = @_;

      $this->{newt} = {};

      # Initialize terminal graphics
      eval q{ use Newt; };
      if ($@) {
	warn "apt-listchanges: In order to use the newt frontend, you must install libnewt-perl\n";
	return undef;
      }

    Newt::Init();
    Newt::Cls();
      my ($screen_width, $screen_height) = Newt::GetScreenSize();
      
      my $longest_pathname = longest(@{ $this->{display_debs} });
      
      # Create widgets
      my $newt = $this->{newt};
      $$newt{main} = Newt::Panel(1,3, 'Reading changelogs');
      $$newt{progress} = Newt::Scale($screen_width - 10, scalar(@debs));
      $$newt{current} = Newt::Label(' ' x length($longest_pathname));
      
      my $main = $$newt{main};
      $main->Add(0, 0, Newt::Label("Scanning packages..."));
      $main->Add(0, 1, $$newt{progress});
      $main->Add(0, 2, $$newt{current});
      $main->Draw();

      1;
    },
    
    'update_progress' => sub {
      my $this = shift;
      my $display_debs = $this->{display_debs};
      my $display_deb = shift @$display_debs;

      my $newt = $this->{newt};
      # Update progress filename
      $newt->{current}->Set( $display_deb );
      $newt->{progress}->Set( ++$this->{debs_processed} );
    Newt::Refresh();
    },
    
    'display_output' => sub {
      my ($this, $output) = @_;

      my $newt = $this->{newt};
      $newt->{confirm} = 1;

      if ($output) {
	my ($screen_width, $screen_height) = Newt::GetScreenSize();
	
	$$newt{main} = Newt::Panel(1, 2, "Displaying changelogs");
	$$newt{main}->Add(0, 0, Newt::Textbox($screen_width - 10, $screen_height - 10,
					      &Newt::NEWT_FLAG_WRAP|
					      &Newt::NEWT_FLAG_SCROLL,
					      $output));
	$$newt{main}->Add(0, 1, Newt::Panel(2, 1)
			  ->Add(0, 0, &Newt::OK_BUTTON)
			  ->Add(1, 0, &Newt::CANCEL_BUTTON));
	
	my ($reason, $data) = $$newt{main}->Run();
	if ($reason eq &Newt::NEWT_EXIT_COMPONENT
	    && $data->Tag() eq 'CANCEL') {
	  $newt->{confirm} = 0;
	};
      }
      
      Newt::Finished();
    },

    'confirm' => sub {
      my ($this) = @_;

      $this->{newt}->{confirm};
    }
  };

  $frontends{'pager'} = {
    'init' => sub {
      my ($this) = @_;

      # Set autoflush on stdout
      $| = 1;

      1;
    },
    
    'update_progress' => sub {
      my ($this) = @_;
      
      my $percent = int(++$this->{debs_processed} / scalar(@debs) * 100);

      printf "Reading changelogs...%s\r",
      $percent == 100 ? "Done" : "$percent%";
    },
    
    'display_output' => sub {
      my ($this, $output) = @_;
      
      print "\n";
      return 0 unless $output;

      my $sigpipe_handler = $SIG{'PIPE'};
      $SIG{'PIPE'} = 'IGNORE';

      open(PAGER, "|/usr/bin/sensible-pager")
	  || die "/usr/bin/sensible-pager: $!\n";

      print PAGER $output;

      close(PAGER);

      $SIG{'PIPE'} = $sigpipe_handler;

      0;
    },

    'confirm' => sub {
      my ($this) = @_;

      unless (open(TTY, "+</dev/tty")) {
	warn "Unable to open tty for confirmation, assuming yes\n";
	return 1;
      }

      TTY->autoflush;

      while (1) {
	print TTY "apt-listchanges: Do you want to continue [Y/n]? ";

	my $response = <TTY>;
	close(TTY);

	return 1 unless $response;
	return 0 if $response =~ /^[Nn]/;
	return 1 if $response =~ /^[Yy]/;
      }
    }
  };

  $frontends{'xterm-pager'} = {
    'init' => $frontends{pager}->{init},

    'update_progress' => $frontends{pager}->{init},

    'display_output' => sub {
      my ($this, $output) = @_;

      return 0 unless $output;

      my $tempfile = `tempfile`;
      chomp($tempfile);

      if (!open(TEMPFILE, ">$tempfile")) {
	warn "apt-listchanges: Unable to open temporary file $tempfile: $!\n";
	return undef;
      }

      print TEMPFILE $output;
      close(TEMPFILE);

      if (!fork) {
	setpgrp();
	chdir("/");
	open(DEVNULL, "<+/dev/null");
	open(STDIN, "<&DEVNULL");
	open(STDOUT, ">&DEVNULL");
	open(STDERR, ">&DEVNULL");

	# We should do TIOCNOTTY here, but Perl doesn't seem to give
	# us its value

	system('x-terminal-emulator', '-e', 'sensible-pager', $tempfile);
	unlink($tempfile);

	exit(0);
      }

      1;
    },

    'confirm' => $frontends{pager}->{confirm}
  };
      
  
  $frontends{'text'} = {
    'init' => $frontends{pager}->{init},
    
    'update_progress' => $frontends{pager}->{update_progress},
    
    'display_output' => sub {
      my ($this, $output) = @_;
      
      print "\n", $output;
      0;
    },

    'confirm' => $frontends{pager}->{confirm}

  };

  $frontends{'mail'} = {
    'init' => sub { 1; },

    'update_progress' => $frontends{pager}->{update_progress},

    'display_output' => sub {
      my ($this, $output) = @_;

      print "\n";

      return 0 unless $output;

      my $host = hostname;

      open(MAIL, "|/usr/lib/sendmail -t") || die "sendmail: $!\n";
      print MAIL <<EOT;
To: $email_address
Subject: apt-listchanges output for $host

EOT
    print MAIL $output;
      close(MAIL);

      print "Changelogs mailed to $email_address\n";
      $? >> 8;
    },

    'confirm' => sub { 1; }

  };

  my $frontend = $frontends{$frontend_opt};
  die "Unknown frontend: $frontend_opt\n" unless defined $frontend;
    
  ## Common stuff for all frontends
  
  # Strip pathnames
  my @display_debs = @debs;
  @display_debs = map { m%([^/]+)$%; $1; } @display_debs;
  $frontend->{display_debs} = \@display_debs;

  # Initialize the frontend
  while (!&{ $frontend->{init} }($frontend)) {
    # Initialization failed, fall back
    my $new_frontend;
    
    if ($frontend eq $frontends{'newt'}) {
      $new_frontend = 'pager';
    } elsif ($frontend eq $frontends{'pager'}) {
      $new_frontend = 'mail';
    } elsif ($frontend eq $frontends{'mail'}) {
      $new_frontend = 'text';
    } elsif ($frontend eq $frontends{'text'}) {
      die "apt-listchanges: Unable to initialize text frontend!  Giving up.\n";
    }

    warn "apt-listchanges: Falling back to $new_frontend frontend\n";
    $frontend = $frontends{$new_frontend};
  }
    
  $frontend;
}

# Find the longest scalar in an array
sub longest {
  my $max;

  foreach my $x (@_) {
    $max = $x if length($x) > length($max);
  }

  $max;
}

sub read_deb_filenames {
  my ($apt_mode, $status) = @_;
  my @debs;

  if ($apt_mode) {

    # In apt mode, see whether apt is new enough to give us the
    # information we need through the pipe.  If not, just read a list of
    # filenames from it.

    my $peek = <>;
    chomp($peek);

    if ($peek =~ /^VERSION (\d+)/) {
      while (<>) {
	# Skip configuration data
	next if 1 .. /^$/;

	next unless my ($pkg, $oldversion, $newversion, $filename)
	    = /^(\S+)\s+(\S+)\s+<\s+(\S+)\s+(\S+)$/;
	next if $filename =~ /^\*\*.*\*\*$/;

	push(@debs, $filename);
	$status{$pkg}{Version} = $oldversion;
	$status{$pkg}{NewVersion} = $newversion; # Not used yet
      }
    } else {

      # Older apt, just read filenames

      # The one we already read
      push(@debs, $peek) if $peek;
      
      while (<>) {
	chomp;
	push(@debs, $_);
      }
    }

  } else {
    # Not in apt mode, use filenames from the command line
    @debs = @ARGV;
  }

  @debs;
}

sub read_config {
  my ($config_file, $config) = @_;

  open(CONF, $config_file) || return undef;
  while (<CONF>) {
    next if /^#/;
    my ($name, $value);
    if ( ($name, $value) = /^([^=]+)=(.*)$/ ) {
      $$config{$name} = $value;
    }
  }
}

##
## All the rest of this stuff should be replaced by a good set of Perl
## bindings for apt (or maybe I should reimplement this in Python)
##

# Extract the package name and version from a .deb file
sub get_package_info {
  my ($deb, $status) = @_;

  my ($pkg, $version, $source);

  open(DPKGDEB, "dpkg-deb -f $deb Package Version Source 2>&1|") || die;
  while (<DPKGDEB>) {
    chomp;
    /^Package: (.*)$/ && do { $pkg = $1 };
    /^Version: (.*)$/ && do { $version = $1 };
    /^Source: (.*)$/ && do { $source = $1 };
  }
  close(DPKGDEB);

  $source ||= $pkg;

  # Look up installed version of $pkg, using the source package
  # version if different
  my $oldversion = $$status{$pkg}{Version};
  if ($$status{$pkg}{Source} =~ /\((.*)\)/) {
    $oldversion = $1;
  }

  # Check for different source package version for the deb
  if ($source =~ /\((.*)\)/) {
    $version = $1;
    $source =~ s/\s*\(.*\)//;
  }

  ($pkg, $version, $oldversion, $source);
}

# Read in package names and versions from the status file and store
# them in the hash ref $status
sub read_status {
  my ($status) = @_;

  # Exit if we already have status info (from apt?)
  return if scalar(keys %$status) > 0;

  my $statusfile = "/var/lib/dpkg/status";

  open(STATUS, $statusfile) || die "$statusfile: $!\n";
  my $pkg;
  while (<STATUS>) {
    /^Package: (.*)$/o && do { $pkg = $1 };
    /^Version: (.*)$/o && do { $$status{$pkg}{Version} = $1 };
    /^Source: (.*)$/o && do  { $$status{$pkg}{Source} = $1; }
  }
  close(STATUS);
}

sub dpkg_compare_versions {
  my ($a, $op, $b) = @_;

  my @cmd = ('dpkg', '--compare-versions', $a, $op, $b);
  my $ret = system(@cmd);
  $ret <<= 8;

  $ret == 0;
}
