#!/usr/bin/perl

#
#      apt-listchanges - Show changelog entries between the installed versions
#        of a set of packages and the versions contained in corresponding
#        .deb files
#
#      Copyright (C) 2000  Matt Zimmerman <mdz@debian.org>
#
#      This program is free software; you can redistribute it and/or modify
#      it under the terms of the GNU General Public License as published by
#      the Free Software Foundation; either version 2 of the License, or
#      (at your option) any later version.
#
#      This program is distributed in the hope that it will be useful,
#      but WITHOUT ANY WARRANTY; without even the implied warranty of
#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#      GNU General Public License for more details.
#
#      You should have received a copy of the GNU General Public
#      License along with this program; if not, write to the Free
#      Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
#      MA 02111-1307 USA
#

use strict;
use Getopt::Long;
use Newt qw(:macros NEWT_FLAG_SCROLL NEWT_FLAG_WRAP NEWT_EXIT_COMPONENT);

# Read config file
my %config;
&read_config('/etc/apt-listchanges.conf', \%config);

# Config file options can be overridden by command line options
my $apt_mode = 0;
my $verbose = 0;
my $frontend_opt = $config{'apt-mode-frontend'} || 'newt';
my $email_address = $config{'apt-mode-email-address'} || 'root';
GetOptions("apt" => \$apt_mode,
	   "verbose|v" => \$verbose,
	   "frontend|f=s" => \$frontend_opt,
	   "email-address=s" => \$email_address) || die;


# List of filenames to process
my @debs;
if ($apt_mode) {
  # In apt mode, read filenames from stdin
  while (<>) {
    chomp;
    push(@debs, $_);
  }
} else {
  # Otherwise, use filenames from the command line
  @debs = @ARGV;
}

unless (@debs) {
  exit 0 if ($apt_mode);
  die "apt-listchanges: Must specify either --apt or filenames to process!\n";
}

# Hash of package info from the status file
my %status;
read_status(\%status);

# Hash of source packages that we've processed (to avoid duplicates)
my %source_packages_processed;

# Numeric urgency values for sorting.  Unknown urgencies get sorted to
# the top (equivalent to 'high'), since there is no fixed list of
# urgency values and it would be much more probable that an unknown
# urgency value would be higher than lower ("this package needs to get
# out at extra-low priority!")
my %urgency = ( 'low' => 2,
		'medium' => 1,
		'high' => 0 );

# Changelog text
my @changes;

# Error text
my $errors;

# User interaction
my $frontend = frontend_init($frontend_opt);

##
## Main loop
##
foreach my $deb (@debs) {
  &{ $frontend->{update_progress} }($frontend);

  my ($pkg, $version) = get_name_and_version($deb);

  $errors .= $version if $pkg eq 'ERROR';

  unless ($pkg) {
    $errors .= "apt-listchanges: Unable to determine package name for $deb\n";
    next;
  }
  unless ($version) {
    $errors .= "apt-listchanges: Unable to determine version for $deb\n";
    next;
  }

  # Look up installed version of $pkg
  my $oldversion = $status{$pkg}{Version};

  my $sourcepackage = $status{$pkg}{Source} || $pkg;

  # Check for different source package version
  if ($sourcepackage =~ /\((.*)\)/) {
    $oldversion = $1;
    $sourcepackage =~ s/\s*\(.*\)//;
  }

  # Skip if the package is not installed
  if (!$oldversion) {
    $changes[$urgency{'low'}] .= "$pkg: will be newly installed\n\n"
	if $verbose;
    next;
  }

  # Skip if we are looking at the same version (faster than asking dpkg)
  if ($version eq $oldversion) {

    $changes[$urgency{'low'}] .=
	"$pkg: Version $version is already installed\n\n"
	if $verbose;

    next;
  }

  # Skip if we are looking at an older version
  if (dpkg_compare_versions($version, 'le', $oldversion)) {
    $changes[$urgency{'low'}] .=
	"$pkg: Version $version is older than installed version ($oldversion)\n\n"
	if $verbose;
    next;
  }

  # Skip if we already processed another binary package from this
  # source package
  next if $source_packages_processed{$sourcepackage}++;

  # Determine the changelog filenames
  my @changelog_filenames = ('changelog.Debian');

  # Check both compressed and uncompressed
  @changelog_filenames = map { ($_, "$_.gz") } @changelog_filenames;

  # Check both /usr/doc and /usr/share/doc
  @changelog_filenames = map { ("./usr/doc/$pkg/$_",
				  "./usr/share/doc/$pkg/$_") }
				  @changelog_filenames;

  my @changelog_filenames_nodebian = @changelog_filenames;

  map { s/\.Debian//g } @changelog_filenames_nodebian;

  # First try changelog.Debian and friends.  If we don't find one, it
  # will be a native package that doesn't provide a changelog.Debian,
  # so we try plain changelog

  foreach my $changelog_filenames (\@changelog_filenames,
				   \@changelog_filenames_nodebian) {

    # Extract relevant changelog info
    open(DPKGDEB, "dpkg-deb --fsys-tarfile $deb | tar xOf - @$changelog_filenames 2>/dev/null | zcat -f|") || die $!;
    
    my $lines_read = 0;
    my $urgency = 0;
    my $changes;
    while (<DPKGDEB>) {
      ++$lines_read;
      
      if ( /^(tar|dpkg-deb):/ ) {
	# Errors from tar or dpkg-deb
	$errors .= $_;
	next;
      }
      
      if ( /^\S+ \((.*)\) \S+; urgency=(.*)$/ ) {
	last if dpkg_compare_versions($1, 'le', $oldversion);

	# Use the urgency of the most urgent changelog entry for the
	# urgency of this package
	$urgency = $urgency{$2} > $urgency ? $urgency{$2} : $urgency;
      }
      
      $changes .= $_;
    }

    $changes[$urgency] .= $changes if $changes;
    
    # Read any remaining data from a large changelog, to avoid a 'broken
    # pipe' error message on close
    while (<DPKGDEB>) {}
    close(DPKGDEB);

    # Quit if we got something (don't try the next set of changelog
    # filenames)
    last if $lines_read > 0;
 }

}

my $output = join('', @changes);
if ($errors) {
  $output .= "\napt-listchanges: Error output follows\n";
  $output .= $errors;
}

exit &{ $frontend->{display_output} }($frontend, $output);

## End top level ##

# Extract the package name and version from a .deb file
sub get_name_and_version {
  my ($deb) = @_;

  my ($pkg, $version);

  open(DPKGDEB, "dpkg-deb -f $deb Package Version 2>&1|") || die;
  while (<DPKGDEB>) {
    chomp;
    /^Package: (.*)$/ && do { $pkg = $1 };
    /^Version: (.*)$/ && do { $version = $1 };
  }
  close(DPKGDEB);

  ($pkg, $version);
}

# Read in package names and versions from the status file and store
# them in the hash ref $status
sub read_status {
  my ($status) = @_;

  my $statusfile = "/var/lib/dpkg/status";

  open(STATUS, $statusfile) || die "$statusfile: $!\n";
  my $pkg;
  while (<STATUS>) {
    /^Package: (.*)$/o && do { $pkg = $1 };
    /^Version: (.*)$/o && do { $$status{$pkg}{Version} = $1 };
    /^Source: (.*)$/o && do { $$status{$pkg}{Source} = $1 };
  }
  close(STATUS);
}

# Find the longest scalar in an array
sub longest {
  my $max;

  foreach my $x (@_) {
    $max = $x if length($x) > length($max);
  }

  $max;
}

sub dpkg_compare_versions {
  my ($a, $op, $b) = @_;

  my @cmd = ('dpkg', '--compare-versions', $a, $op, $b);
  my $ret = system(@cmd);
  $ret <<= 8;

  $ret == 0;
}

sub read_config {
  my ($config_file, $config) = @_;

  open(CONF, $config_file) || return undef;
  while (<CONF>) {
    next if /^#/;
    my ($name, $value);
    if ( ($name, $value) = /^([^=]+)=(.*)$/ ) {
      $$config{$name} = $value;
    }
  }
}

# Initialize the frontend...this is a little bit hairy.  We return a
# reference (really, a fake object) containing subroutine refs called
# update_progress and display_output.  These expect to be called with
# a reference to the fake object as their first argument, just as a
# real object's methods would.  The code for all of the frontends is
# in here.

sub frontend_init {
  my ($frontend_opt) = @_;
  
  my %frontends;
  $frontends{'newt'} = {
    'init' => sub {
      my ($this) = @_;
      $this->{newt} = {};
      # Initialize terminal graphics
    Newt::Init();
    Newt::Cls();
      my ($screen_width, $screen_height) = Newt::GetScreenSize();
      
      my $longest_pathname = longest(@{ $this->{display_debs} });
      
      # Create widgets
      my $newt = $this->{newt};
      $$newt{main} = Newt::Panel(1,3, 'Reading changelogs');
      $$newt{progress} = Newt::Scale($screen_width - 10, scalar(@debs));
      $$newt{current} = Newt::Label(' ' x length($longest_pathname));
      
      my $main = $$newt{main};
      $main->Add(0, 0, Newt::Label("Scanning packages..."));
      $main->Add(0, 1, $$newt{progress});
      $main->Add(0, 2, $$newt{current});
      $main->Draw();
    },
    
    'update_progress' => sub {
      my $this = shift;
      my $display_debs = $this->{display_debs};
      my $display_deb = shift @$display_debs;
      
      my $newt = $this->{newt};
      # Update progress filename
      $newt->{current}->Set( $display_deb );
      $newt->{progress}->Set( ++$this->{debs_processed} );
    Newt::Refresh();
    },
    
    'display_output' => sub {
      my ($this, $output) = @_;

      my $ret = 0;
      if ($output) {
	my ($screen_width, $screen_height) = Newt::GetScreenSize();
	
	my $newt = $this->{newt};
	$$newt{main} = Newt::Panel(1, 2, "Displaying changelogs");
	$$newt{main}->Add(0, 0, Newt::Textbox($screen_width - 10, $screen_height - 10,
					      NEWT_FLAG_WRAP|NEWT_FLAG_SCROLL,
					      $output));
	$$newt{main}->Add(0, 1, Newt::Panel(2, 1)
			  ->Add(0, 0, OK_BUTTON)
			  ->Add(1, 0, CANCEL_BUTTON));
	
	my ($reason, $data) = $$newt{main}->Run();
	if ($reason eq NEWT_EXIT_COMPONENT && $data->Tag() eq 'CANCEL') {
	  # User pressed cancel, so we should exit with nonzero status
	  $ret = 1;
	};
      }
      
      Newt::Finished();
      $ret;
    }
  };
  
  $frontends{'pager'} = {
    'init' => sub {
      my ($this) = @_;

      # Set autoflush on stdout
      $| = 1;
    },
    
    'update_progress' => sub {
      my ($this) = @_;
      
      my $percent = int(++$this->{debs_processed} / scalar(@debs) * 100);

      printf "Reading changelogs...%s\r",
      $percent == 100 ? "Done" : "$percent%";
    },
    
    'display_output' => sub {
      my ($this, $output) = @_;
      
      print "\n";
      return 0 unless $output;

      my $sigpipe_handler = $SIG{'PIPE'};
      $SIG{'PIPE'} = 'IGNORE';

      open(PAGER, "|/usr/bin/sensible-pager")
	  || die "/usr/bin/sensible-pager: $!\n";

      print PAGER $output;

      close(PAGER);

      $SIG{'PIPE'} = $sigpipe_handler;

      $? >> 8;
    }
  };

  $frontends{'text'} = {
    'init' => sub {},
    
    'update_progress' => $frontends{pager}->{update_progress},
    
    'display_output' => sub {
      my ($this, $output) = @_;
      
      print "\n", $output;
      0;
    }
  };

  $frontends{'mail'} = {
    'init' => sub {},

    'update_progress' => $frontends{pager}->{update_progress},

    'display_output' => sub {
      my ($this, $output) = @_;

      print "\n";

      open(MAIL, "|/usr/lib/sendmail -t") || die "sendmail: $!\n";
      print MAIL <<EOT;
To: $email_address
Subject: apt-listchanges output

EOT
    print MAIL $output;
      close(MAIL);

      print "Changelogs mailed to $email_address\n";
      $? >> 8;
    }
  };

  my $frontend = $frontends{$frontend_opt};
  die "Unknown frontend: $frontend_opt\n" unless defined $frontend;
    
  ## Common stuff for all frontends
  
  # Strip pathnames
  my @display_debs = @debs;
  @display_debs = map { m%([^/]+)$%; $1; } @display_debs;
  $frontend->{display_debs} = \@display_debs;
  
  # Initialize the frontend
  &{ $frontend->{init} }($frontend);
  
  $frontend;
}
